Summary email from 09/25/2015

So Mike and I have done some talking about the OL catalog I proposed in my advancement. In figuring out what goes in and what doesn't (both in terms of "how to describe a logic" and "what are logics and what aren't"), we kept bumping into the question of the exact distinction (if any) between OLs and these things we had somewhat tentatively called models in our combat paper. Mike and I think we have a stronger account of that difference now, which I'll summarize.

We want a distinction between models ("what games can be about") and OLs ("how games are about things", to be horribly reductive). I personally want this to avoid addressing an infinity of OLs in my hyper-hyperformalism, and I think the recipients all have their own aesthetic reasons for wanting a small number of OLs.

Briefly, we see three (still "soft") differences:
1. Models generally incorporate more cultural knowledge, to the point that even the name of a game or cabinet art can induce a (partially-justified) model (e.g. BurgerTime + chef character => I'm cooking burgers!). 
2. Models describe abstract processes similarly to OLs, but at a much higher ("unimplementable") level of abstraction.
3. Models can be satisfied/induced by distinct arrangements of OLs' operations with instantial assets and affordances of other models, and this always terminates eventually in the operations of OLs and in instantial assets. OLs don't have this property: they _are_ the terminal nodes.

(3) draws attention to the implementation of gravity and "physics" in PuzzleScript using pattern matching. In my advancement I argued that if the player perceives physics, there is a physics logic; the author may see different affordances and even logics than the player. But this reasoning that says "ignore the implementing substrate" breaks down in two directions. First, we would like to be able to describe how the author creates levels with physical objects without throwing up our hands and giving up. Second, we would like to understand cases like the movement of a character in Dragon Quest or Final Fantasy, where continuous animation suggests "physics" but the rules of the simulation constrain movement to tile boundaries. In the past we have used terms like "trivial model of space" or "trivial physics logic", further confusing the distinction between logic and model. I also have these frankly iffy "ontological commitments/provisions" fields in the OL catalog. What are those?

They're models. A collision logic induces a model of space because it satisfies modeling obligations that lead us to believe objects exist in a physical space, as opposed to a non diegetic space like UI elements. A physics logic induces a physics model of (e.g. Newtonian) mechanics and continuous, "realistic" movement referring to our own experience of springs or rag dolls. If two logics "depend on" a model of space or of persistent entities, then it must be that they are _consistent_ with respect to those models (and the role of the compositional glue is to map out this consistency).

When we implement gravity in PuzzleScript we are _modeling_ physics without using a physics logic. Could we superimpose a physics logic and analyze the game based on that? Maybe! But that is a _different implementation_ which will act differently! In this sense only models may be "trivial". The movement in Dragon Quest strongly models discrete space via its collision logic and that's how players read it, while weaker interpretations of continuous space, velocity, etc can be gleaned from the animations of the character-state logic.

As a final example, let's consider turn-taking in Chess and in Final Fantasy Tactics. The former we could model as a "game mode logic" state machine and the latter as a resource logic. The former communicates via some UI label like "White's Turn" and pieces respond to clicks; the latter by centering the camera on the active unit and putting an icon over its head and showing a menu of actions. But these are not communicative strategies of resource logics!

We could say that a character state logic puts the unit into an active state, but then the menu (game mode?) and camera are still unexplained; this also doesn't account for delayed actions, which are scheduled in a similar way to units. The connection of the menu options to the behavior of the unit is also unexplained. But if we return to Chess, we have the same kind of problem: game mode logics generally communicate via different "screens" with a process that puts different logics and modes of interaction at work. A game progression logic is also a bad fit because of the cyclic nature of turn taking. The menus of Final Fantasy described in the combat paper had a similar issue.

We can resolve much of this by asserting that "scheduling" is a model, which may be trivial ("round robin") or complex, and by postulating a _control logic_ whose process arbitrates which inputs may be dispatched where: _who_ may control _what_ and _how_., _when_ This logic communicates via UI elements or decorations, by camera focus, by sprite animations, by command prompts, etc. This also could be put to the possession of one player character by another player, or to the reversal of input directions, etc; and it hopefully removes the need to query for concrete button presses in the physics or character state logics. Control can be partially modeled with character states like hitstun, but it's hard to extend that to a full control logic.

Control and resource logics working together yield a more complete explanation of the scheduler of Final Fantasy Tactics. ((Note that the triggering, animations, & effects of delayed actions like spells are still unaccounted for. Some kind of "event/scripting logic" seems necessary and could also address e.g. cutscenes, opening treasure chests, battles which must be lost to proceed, or switch/door puzzles. But we can talk about that later.))

Models of scheduling, compared to control logics, are much more abstract and could be realized without respect to units (e.g., to a schedule of upcoming events in a resource management simulation). They don't need much cultural knowledge but do need some (some people have better reaction times than others; doing lots of things in quick succession is fatiguing so it makes sense my turn will come up later if I do more; etc).

Finally, it's worth noting that, like the BurgerTime player and cooking, a novice Tactics player has a superficial model of the scheduler. Unlike BurgerTime, this model becomes more sophisticated but is not totally discarded as their knowledge of the game increases, until eventually it is understood at the level of resource transactions instead of (or in addition to) the passage of time. This is another argument that scheduling is a model rather than a logic: it can be used without being understood.